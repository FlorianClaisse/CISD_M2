source("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé/ACP.R")
getwd()
source("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé/ACP.R")
getwd()
source("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé/ACP.R")
install.packages("GGally")
install.packages(c("corrplot", "data.table", "doBy", "emmeans", "evaluate", "igraph", "Matrix", "quantreg", "rstudioapi"))
library(FactoMineR)
library(GCally)
library(GGally)
library("FactoMineR")
source("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé/ACP.R")
source("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé/ACP.R")
source("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé/ACP.R")
setwd("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé")
source("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé/ACP.R")
load("données/eaux.rda")
source("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé/ACP.R")
source("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé/ACP.R")
source("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé/ACP.R")
# Manipulation des données
X[, 1:3] # les 3 premières colonnes
X[, c(1,5)] # la première et la 5ème colonne
X[, -c(1,5)] # toutes les colonnes sauf la première et la 5ème
X[1:3, ] # les 3 premières lignes
class(X) # Un data.frame est une liste dont les éléments sont les colonnes
X$saveur.amère # On récupère les élements d’une liste avec le $
X$saveur.amère # On récupère les élements d’une liste avec le $
X[ ,1]
# Moyenne de la variable saveur amère
sum(X$saveur.amère)/n
mean(X$saveur.amère)
# Ecart-type de la variable saveur amère
x <- X$saveur.amère
sqrt(1/(n-1)*sum((x-mean(x))^2))
sd(x)
source("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé/ACP.R")
# Moyenne et écart-type de toutes les variables
moy <- apply(X, 2, mean) # 1=lignes, 2=colonnes
sigma <- apply(X,2, sd) #standard deviation
source("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé/ACP.R")
####################### Centrer Reduire #######################################
# Création des données centrées ...
2 Y <- sweep(X, 2, moy, "-")
####################### Centrer Reduire #######################################
# Création des données centrées ...
Y <- sweep(X, 2, moy, "-")
apply(Y, 2, mean) # les colonnes sont bien centrées
Z <- sweep(Y, 2, sigma, "/")
apply(Z, 2, sd) # les colonnes sont bien de variance 1
# ou de manière équivalente
Z <- scale(X)
# ou avec l’écart-type non corrigé (comme en ACP)
Z <- scale(X)*sqrt(n/(n-1))
######################## Description bivariée #################################
# Avec la fonction ggpairs du package GGally
ggpairs(X[,1:5])
# Cacluler et visualiser la matrice de corrélation
z1 <- Z[, 1] # variable saveur amère standardisée
# Cacluler et visualiser la matrice de corrélation
z1 <- Z[, 1] # variable saveur amère standardisée
z2 <- Z[, 2] # variable saveur sucrée standardisée
sum(z1*z2)/n # corrélation entre les deux variables
cor(X$saveur.amère, X$saveur.sucrée)
cor(X[,1:5]) # matrice des corrélations entre les 5 première variables
ggcorr(X[,1:5])
# Matrice des distances entre les individus
dist(X) # données brutes
dist(Y) # données centrées
dist(Z) # données centrées-réduites
# Corrélation entre les variables
cor(X)
# ou encore
t(Z) %*% Z/n # %*% est le produit matriciel
# Corrélation entre les variables
cor(X)
clear
# ou encore
t(Z) %*% Z/n # %*% est le produit matriciel
################## ACP sur matrice de covariance ##############################
# Fonction PCA du package FactoMineR
# (scale.unit=FALSE)
res <- PCA(X, graph = FALSE, scale.unit = FALSE)
################## ACP sur matrice de covariance ##############################
# Fonction PCA du package FactoMineR
# (scale.unit=FALSE)
res <- PCA(X, graph = FALSE, scale.unit = FALSE)
# Figure individus
plot(res,choix = "ind", cex = 1.5, title = "")
# Figure variables
plot(res, choix = "var", cex = 1.5, title = "")
# Equivalent à la décomposition en valeurs propres de la matrice des covariances
Y <- as.matrix(Y)
C <- (t(Y) %*% Y)/n # matrice des covariances
eigen(C)$values
res$eig[, 1]
#################### ACP sur matrice de correlation ###########################
# Analyse en composantes principales normalisée (sur matrice des corrélations)
# (par défaut: scale.unit=TRUE)
res <- PCA(X, graph=FALSE)
# Figure individus
plot(res, choix = "ind", cex = 1.5, title = "") # plan 1-2
plot(res, choix = "ind", axes=c(2,3), cex = 1.5, title = "") # plan 2-3
# Figure variables
plot(res, choix = "var", cex = 1.5, title = "") # plan 1-2
plot(res, choix = "var", axes=c(2,3), cex = 1.5, title = "") # plan 2-3
# Equivalent à la décomposition en valeurs propres de la matrice des corrélations
R <- (t(Z) %*% Z)/n # matrice des corrélations
eigen(R)$values
res$eig[, 1]
# Récuperer les 2 premières compostantes principales
F <- res$ind$coord[, 1:2]
plot(F, pch = 16)
text(F, rownames(X), pos = 3) # on retrouve la figure des individus
# Récuperer les loadings (corrélations aux deux premières CP)
A <- res$var$coord[, 1:2]
plot(A, pch=16)
text(A, colnames(X), pos = 3) # on retrouve la figure des variables
A[1, , drop=FALSE] # corrélations entre saveur amère et les 2 premières CP
cor(F, X$saveur.amère)
############################# Interpretation ##################################
# Inertie (variance) des composantes principales
apply(F, 2, var)*(n-1)/n # variances des 2 premières CP
res$eig[, 1]
sum(res$eig[, 1])
res$eig
# Qualité de la projection des individus sur les axes
2 res$ind$cos2
# Qualité de la projection des individus sur les axes
res$ind$cos2
# Qualité de la projection des individus sur le premier plan
4 apply(res$ind$cos2, 1, sum)
# Qualité de la projection des individus sur le premier plan
apply(res$ind$cos2, 1, sum)
source("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé/ACP.R")
# Qualité de la projection des variables sur les axes
res$var$cos2
# Qualité de la projection des variables sur le premier plan
apply(res$var$cos2, 1, sum) # ou regarder la longeur des flèches !
source("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé/ACP.R")
setwd("~/Documents/Enseirb/Analyse_des_donnees/1_Non_Suppervisé")
# Données sur les fromages
X <- read.table("données/fromage.txt", sep="", header=TRUE, row.names=1)
n <- nrow(X)
p <- ncol(X)
##################### Moyenne et ecart type ##################################
# Calcul de la moyenne et de l’écart type des variables
moy <- apply(X, 2, mean)
sigma <- apply(X, 2, sd)*sqrt((n-1)/n) #écart-type non corrigé
# Création des données centrées ...
Y <- sweep(X, 2, moy, "-")
# ... et réduites
Z <- sweep(Y, 2, sigma, "/")
################################# Fixer le nombre de cluster ##################
# Nombre de clusters souhaité
K <- 5
################################### kmeans ####################################
# kmeans en 5 classes sur données standardisées
km <- kmeans(Z, centers=K, nstart=50)
km$cluster # la partition
table(km$cluster) # effectifs des classes
km$withinss # inertie de chaque classe (within sum of squares)
km$betweenss # inertie inter-classe (between sum of squares)
km$totss # inertie totale (total sum of squares)
sum(km$withinss) + km$betweenss # inertie total= inta + inter
km$betweenss/km$totss # pourcentage d’inertie expliquée par la partition
###################### Nouvelle variables quantitative ########################
# La partition est une nouvelle variable qualitative
part <- as.factor(km$cluster) # object de classe factor
levels(part) <- paste("cluster", 1:K, sep="") # modalités de la variable
# Un data.frame mélange les colonnes numériques et qualitatives !
Xplus <- data.frame(X, part)
View(Xplus)
################################ Visualisation ################################
# ACP normée en mettant la variable "part" en illustrative
res <- PCA(Xplus, quali.sup="part", graph = FALSE)
res$eig
plot(res, choix = "ind", habillage = "part", invisible = "quali")
plot.PCA(res, choix = "var")
# Interprétation des classes avec la fonction catdes
des <- catdes(Xplus, num.var = 10)
des$quanti$cluster1
des$quanti$cluster2
# Classification hiérarchique de Ward sur données centrées-réduites
D <- dist(Z)
tree <- hclust(D^2/(2*n), method = "ward.D")
plot(tree, hang=-1, main="Dendrogramme de Ward", xlab="", sub = "")
tree$height
sum(tree$height) # Inertie totale
############### Comparaison 5 WARD et 5 kmeans ################################
# Partition en 5 classes avec la CAH de Ward
K <- 5
plot(tree, hang=-1, main="", sub="", xlab="")
rect.hclust(tree, k=K)
part_ward <- cutree(tree, k=K) # partition en 5 classes
# Comparaison avec la partition en 5 classes des kmeans
table(part_ward) # effectif des classes de la partition de Ward
table(km$cluster) # effectifs des classes de la partition des kmeans
table(part_ward, km$cluster) # tableau de contingence entre les deux partitions
W <- sum(tree$height[1:(n-K)]) # inertie intra-classe de la partition de Ward
(1-W/9)*100 # Pourcentage d’inertie expliquée à comparer avec les kmeans
############################# Charger les données #############################
load("données/chiens.rda")
res <- MCA(chiens, graph = FALSE) # Multiple Correspondance Analysis
res$eig # 10 valeurs propres non nulles
res <- MCA(chiens, ncp=10, graph = FALSE) # 10 composantes principales
F <- res$ind$coord # données recodées
################################### CAH de WARD ###############################
tree <- hclust(dist(F)^2/(2*nrow(F)), method="ward.D")
plot(tree, hang=-1)
################################### Couper le dendogramme #####################
part <- cutree(tree, k=4) # partition en 4 classes
part <- as.factor(part)
levels(part) <- paste("cluster", 1:4, sep="")
des <- catdes(data.frame(part, chiens), num.var=1)
des$category
gc()
gc()
gc()
